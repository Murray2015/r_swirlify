well164_28_1 = read.csv('data_files/well_td_curves/164-28-1TD.dat', sep="\t")
well19_5_1 = read.csv('data_files/well_td_curves/19-5-1TD.dat', sep="\t")
well47_13_1 = read.csv('data_files/well_td_curves/47-13-1.dat', sep="\t")
## Make a regression function for rockall
# temp1 = rbind(well154_01_1[,],  well164_27_1[,], well164_28_1[,],well47_13_1[,])
# temp2 = rbind(well154_3_1[,], well164_25_1[,],well132_06_1[,], well132_15_1[,])
# names(temp2) = c("MD.Meters.", "Time..2.way.")
# all_wells2 = rbind(temp1, temp2)
## At this point, I'm now confused if I should be using time below seafloor or just time. And have I used it correctly further down this script, forget about in the part 1 script...
# Subtract the first depth from all depths and first time from all times. This is then the time below and depth below seafloor (Check shaw-champion first)
well_extract = function(well,name){
return(data.frame(depth_below_seafloor=(well[,1][-1] - well[,1][2]), time_below_seafloor= well[,2][-1] - well[,2][2], name=factor(name)))
}
well132_06_1_new = well_extract(well132_06_1, 'well_132_06_1' )
well132_15_1_new  = well_extract(well132_15_1, 'well_132_15_1')
well154_01_1_new  = well_extract(well154_01_1, 'well_154_01_1')
well154_3_1_new  = well_extract(well154_3_1, 'well_154_3_1')
well164_25_1_new  = well_extract(well164_25_1, 'well_164_25_1')
well164_27_1_new = well_extract(well164_27_1, 'well_164_27_1')
well164_28_1_new  = well_extract(well164_28_1, 'well_164_28_1')
# well19_5_1_new  = well_extract(well19_5_1, 'well_19_5_1')
well47_13_1_new  = well_extract(well47_13_1, 'well_47_13_1')
# Concatenate all the dataframes
all_wells = rbind(well132_06_1_new, well132_15_1_new, well154_01_1_new, well154_3_1_new, well164_25_1_new, well164_27_1_new, well164_28_1_new,
well47_13_1_new)
# Make a plot of this, and print the equation of the regression line. Colour points by well name?
a = lm(all_wells$depth_below_seafloor ~ poly(all_wells$time_below_seafloor, 2, raw=TRUE))
ggplot(all_wells, aes(y=depth_below_seafloor/1000, x=time_below_seafloor)) + geom_point(aes(color=name)) + scale_y_reverse() + scale_color_brewer(name="Well",palette="Set1") + xlab('Time below seafloor (s)') + ylab('Depth below seafloor (km)') + geom_smooth(method='lm',formula=y ~ poly(x, 2)) + annotate("text", label = paste('y = ', round(summary(a)$coefficients[1],2) , " + ", round(summary(a)$coefficients[2],2) , "x + ", round(summary(a)$coefficients[3],2) , "x^2"), x = 1, y = 3.5, size = 5, colour = "red") +scale_x_continuous(position = "top")
# ggsave('ch2_time_depth_curves.jpg', width=6, height=5, units='in', dpi=300)
setwd("~/Documents/thesis_r_code")
data = read.csv('sills.csv', na.strings=c("NA","NaN", " "))
library(tidyverse)
# Reassigne Fernandez's complex to irregular
data$shape[data$shape=='Complex'] = 'Irregular'
# Reassesment of the only fault block example shows it cuts the fault on one side, so is flat.
data$shape[data$shape=='Faultblock'] = 'Flat'
data[data$shape == "", 'shape'] = NA
library(plyr)
data$usingfaults = revalue(data$usingfaults, c("N"="Intruding sediment", "Y"="Intruding faults"))
data[data$usingfaults == "", 'usingfaults'] = NA
subset1 = subset(data, data$datasetme != 'Modelling' & data$datasetme != 'Norway' & data$datasetme != 'New Zealand')
ggplot(subset1,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1")
# ggsave(filename="ch2_basin_shape.jpg", width=6, height=4, units='in', dpi=300)
subset2 = subset(data, data$datasetme != 'Modelling' & data$datasetme != 'Norway' & data$datasetme != 'New Zealand' & data$datasetme != 'Hatton' & data$datasetme != 'Karoo' & data$datasetme != 'Porcupine' & data$datasetme != 'SlyneErris' & data$datasetme != 'IrishRockall')
# Rename 'Coverak' as 'Carnarvon'
subset2$datasetme = revalue(subset2$datasetme, c("Coverak"="Carnarvon"))
ggplot(subset2,aes(x = datasetme, fill = usingfaults)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Fault intrusion') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('', palette="Set1")
# ggsave(filename="ch6_sills_faults.jpg", width=6, height=4, units='in', dpi=300)
subset1$datasetme = revalue(subset1$datasetme, c("Coverak"="Carnarvon"))
ggplot(subset1,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1")
ggplot(subset1,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1")
ggsave(filename="ch2_basin_shape.jpg", width=6, height=4, units='in', dpi=300)
rockall_subsets = subset(data, datasetme=="Rockall" || datasetme=="IrishRockall")
nrow(rockall_subsets)
rockall_subsets = subset(data, datasetme=="Rockall")
nrow(rockall_subsets)
rockall_subsets = subset(data, c(datasetme=="Rockall" || datasetme=="IrishRockall"))
nrow(rockall_subsets)
rockall_subsets = subset(data, datasetme=="Rockall" | datasetme=="IrishRockall")
nrow(rockall_subsets)
head(rockall_subsets)
ggplot(subset1,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1")
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1")
names(rockall_subsets)
#table(data$datasetme)
data$three_D_survey[data$datasetme =='Bight' | data$datasetme =='Hatton' | data$datasetme == 'New Zealand' |  data$datasetme == 'IrishRockall'] = as.character('2D')
data$three_D_survey[data$datasetme == 'Coverak' | data$datasetme =='FSB' | data$datasetme == 'Judd' | data$datasetme == 'SlyneErris' |data$datasetme=='Rockall'] = as.character('3D')
data$three_D_survey[data$datasetme == 'Karoo' ] = as.character('NA')
data$three_D_survey = factor(data$three_D_survey)
subset1 = subset(data, data$datasetme != 'Modelling' & data$datasetme != 'Norway' & data$datasetme != 'New Zealand')
subset1$datasetme = factor(subset1$datasetme)
# mean(data$longlengthfull[data$three_D_survey==0], na.rm=TRUE)
# mean(data$longlengthfull[data$three_D_survey==1], na.rm=TRUE)
ggplot(subset1) + geom_boxplot(aes(x=datasetme, y=longlengthfull, fill=three_D_survey)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer(palette="Set1") + xlab('Dataset name') + ylab('Sill diameter (m)') + scale_fill_discrete(name="Data type")
# ggsave('ch2_basin_length_2d3d.jpg',dpi=300, width=6, height=4, units='in')
data$transgreshight_time = data$timedeepest - data$timeshallowest
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(three_D_survey)
rockall_subsets = subset(data, datasetme=="Rockall" | datasetme=="IrishRockall")
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(three_D_survey)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(data$three_D_survey)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(.three_D_survey)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(.data$three_D_survey)
names(rockall_subsets)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(.data$three_D_survey)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(.~data$three_D_survey)
ggplot(rockall_subsets,aes(x = datasetme, fill = shape)) +
geom_bar(position='fill') + xlab('Dataset name') + ylab('Proportion') + ggtitle('Sill shape data') + theme(axis.text.x = element_text(angle = 90, hjust = 1))  + scale_fill_brewer('Shape', palette="Set1") + facet_grid(.~rockall_subsets$three_D_survey)
image
?image
## Use the workflow from R notebook 2 to read in the NetCDF file
# Set the working directory to where the data files are saved
setwd("~/Documents/scratch/R_netcdf") # This is the file path to where I have saved my data files on my computer. Your file path will be different. Either use Windows Explorer (Finder on a mac) to find the file path, or use the menu at the top of R studio to set the working directory instead. If you want to use the menu instead of this line of code, at the top of R studio click Session >  Set working directory > Choose directory, and navigate to the folder where the data files are saved. Finally, note windows users need to use two backslashes (i.e. \\) rather than a single forward slash. This is one of those differences between Windows and Mac/Linux.
# Load the ncdf4 library into R. (note, we installed this with install.packages() in Notebook 2)
library("ncdf4")
# Open a file connection to the NetCDF file
ncfile <- nc_open("lpj-guess_agmerra_fullharm_yield_mai_global_annual_1980_2010_C360_T0_W0_N60_A0_1deg.nc4")
# Print the NetCDFs header
print(ncfile)
# Extract variables from the NetCDF file
lat=ncvar_get(ncfile, 'lat')
lon=ncvar_get(ncfile,'lon')
time=ncvar_get(ncfile, "time")
yield = ncvar_get(ncfile, 'yield_mai')
# Close the NetCDF file connection
nc_close(ncfile)
# Extract the first time slice from the NetCDF file as a matrix, and store in a variable called first_yield_slice.
first_yield_slice = yield[,180:1,1]
# Make a quick plot of the first time slice
image(first_yield_slice)
# The last plot seemed to have no data, so to trouble shoot, lets check the matrix of data in first_yield_slice has the dimensions we expect with the dim() function
dim(first_yield_slice)
# The dimensions seemed fine, so to continue to troubleshoot let's trying selecting a different time slice. Maybe it's just the first time slice that is empty.
first_yield_slice = yield[,180:1,2]
image(first_yield_slice)
# Let's make a difference map by subtracting one time slice from another.
# Load the fields package for plots with a colourbar. We installed the fields package with install.packages() in Notebook 2.
library("fields")
# Select the second time slice and store in a variable called yield2. Note the 180:1 in the lattitude space, which flips the matrix (as it is upside down in the yield variable)
yield2 = yield[,180:1,2]
# # Select the third time slice and store in a variable called yield3. Note the 180:1 in the lattitude space, which flips the matrix (as it is upside down in the yield variable)
yield3 = yield[,180:1,3]
# Find the difference between the two matrixs of data.
yield_difference = yield3 - yield2
# Make a plot of the difference
image.plot(yield_difference, legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))")
image.plot(yield_difference, legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-5,5))
# Load the RColorBrewer library (which we installed in Notebook 2 with the install.packages() function) to give us more colour ramps.
library("RColorBrewer")
# Remake the difference map with a polar colour pallete (i.e. cold to hot colours) with 9 levels. Note the rev() function used to reverse the colour pallete, as by default it goes from red to blue not blue to red.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))")
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))")
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-5,5))
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4.5,4.5))
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
map()
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
map(add=T)
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
map(add=T, col='gray')
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
map(add=T, col='gray', lwd=0.5)
# Make a temporary slice with the data flipped the right way up. Makes everything less complicated!
temp_slice = yield[,180:1,2]
# The tropic of Capricorn is at 23 degrees north. However remember our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 + 23 to find the tropic of capricorn on our grid.
tropic_capricorn = 90+23
# Similar to the tropic of Capricorn above, the tropic of cancer is at is at 23 degrees south. However our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 - 23 to find the tropic of cancer on our grid.
tropic_cancer = 90-23
# Subset our grid with the square bracket notation. leave the first space blank to select all of the lonitudes. The use the colon notation to select the range of values between the tropic of Cancer and the tropic of Capricorn.
tropics_yield_slice = temp_slice[ , tropic_cancer:tropic_capricorn]
# Make a quick plot of our subsetted data. It will obviously look distorted as it is being streched by the image function. There are several ways to make a correctly scaled map for a subset, but that is outside of the scope of this R notebook.
image(tropics_yield_slice)
# Make a temporary slice with the data flipped the right way up. Makes everything less complicated!
temp_slice = yield[,180:1,2]
# The tropic of Capricorn is at 23 degrees north. However remember our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 + 23 to find the tropic of capricorn on our grid.
tropic_capricorn = 90+23
# Similar to the tropic of Capricorn above, the tropic of cancer is at is at 23 degrees south. However our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 - 23 to find the tropic of cancer on our grid.
tropic_cancer = 90-23
# Subset our grid with the square bracket notation. leave the first space blank to select all of the lonitudes. The use the colon notation to select the range of values between the tropic of Cancer and the tropic of Capricorn.
tropics_yield_slice = temp_slice[ , tropic_cancer:tropic_capricorn]
# Make a quick plot of our subsetted data. It will obviously look distorted as it is being streched by the image function. There are several ways to make a correctly scaled map for a subset, but that is outside of the scope of this R notebook.
image(tropics_yield_slice)
map(add=T)
max(yield_difference, na.rm=T)
min(yield_difference, na.rm=T)
## Use the workflow from R notebook 2 to read in the NetCDF file
# Set the working directory to where the data files are saved
setwd("~/Documents/scratch/R_netcdf") # This is the file path to where I have saved my data files on my computer. Your file path will be different. Either use Windows Explorer (Finder on a mac) to find the file path, or use the menu at the top of R studio to set the working directory instead. If you want to use the menu instead of this line of code, at the top of R studio click Session >  Set working directory > Choose directory, and navigate to the folder where the data files are saved. Finally, note windows users need to use two backslashes (i.e. \\) rather than a single forward slash. This is one of those differences between Windows and Mac/Linux.
# Load the ncdf4 library into R. (note, we installed this with install.packages() in Notebook 2)
library("ncdf4")
# Open a file connection to the NetCDF file
ncfile <- nc_open("lpj-guess_agmerra_fullharm_yield_mai_global_annual_1980_2010_C360_T0_W0_N60_A0_1deg.nc4")
# Print the NetCDFs header
print(ncfile)
# Extract variables from the NetCDF file
lat=ncvar_get(ncfile, 'lat')
lon=ncvar_get(ncfile,'lon')
time=ncvar_get(ncfile, "time")
yield = ncvar_get(ncfile, 'yield_mai')
# Close the NetCDF file connection
nc_close(ncfile)
# Extract the first time slice from the NetCDF file as a matrix, and store in a variable called first_yield_slice.
first_yield_slice = yield[,180:1,1]
# Make a quick plot of the first time slice
image(first_yield_slice)
# The last plot seemed to have no data, so to trouble shoot, lets check the matrix of data in first_yield_slice has the dimensions we expect with the dim() function
dim(first_yield_slice)
# The dimensions seemed fine, so to continue to troubleshoot let's trying selecting a different time slice. Maybe it's just the first time slice that is empty.
first_yield_slice = yield[,180:1,2]
image(first_yield_slice)
# Let's make a difference map by subtracting one time slice from another.
# Load the fields package for plots with a colourbar. We installed the fields package with install.packages() in Notebook 2.
library("fields")
# Select the second time slice and store in a variable called yield2. Note the 180:1 in the lattitude space, which flips the matrix (as it is upside down in the yield variable)
yield2 = yield[,180:1,2]
# # Select the third time slice and store in a variable called yield3. Note the 180:1 in the lattitude space, which flips the matrix (as it is upside down in the yield variable)
yield3 = yield[,180:1,3]
# Find the difference between the two matrixs of data.
yield_difference = yield3 - yield2
# Make a plot of the difference
image.plot(yield_difference, legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))")
# Load the RColorBrewer library (which we installed in Notebook 2 with the install.packages() function) to give us more colour ramps.
library("RColorBrewer")
# Remake the difference map with a polar colour pallete (i.e. cold to hot colours) with 9 levels. Note the rev() function used to reverse the colour pallete, as by default it goes from red to blue not blue to red.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))")
# Center the colourbar at 0 by controlling the values for z (in this case, colour of the variable) to have the same value for negative and posative values, e.g. -5 and 5, or -261 and 261, or whatever value. Note we again use the concatenate function "c()" to enclose the two values.
image.plot(lon, lat, yield_difference, col=rev(brewer.pal(9,'RdBu')), legend.lab="Difference in yields (t ha-1 yr-1 (dry matter))", zlim=c(-4,4))
map(add=T, col='gray', lwd=0.5)
# Find the mean of our difference between slices 2 and 3.
mean(yield_difference)
# Find the difference between slices 2 and 3, removing NAs before.
mean(yield_difference, na.rm=T)
# Find other summary statistics for the difference between slices 2 and 3.
median(yield_difference, na.rm=T)
sd(yield_difference, na.rm=T) # the sd function returns the standard deviation.
max(yield_difference, na.rm=T)
min(yield_difference, na.rm=T)
# Make a temporary slice with the data flipped the right way up. Makes everything less complicated!
temp_slice = yield[,180:1,2]
# The tropic of Capricorn is at 23 degrees north. However remember our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 + 23 to find the tropic of capricorn on our grid.
tropic_capricorn = 90+23
# Similar to the tropic of Capricorn above, the tropic of cancer is at is at 23 degrees south. However our matrix starts at 0 at the bottom corner and goes up to 180 at the top corner, rather than the usual -90 degrees of the south pole and +90 degrees at the north pole. So we need to do 90 - 23 to find the tropic of cancer on our grid.
tropic_cancer = 90-23
# Subset our grid with the square bracket notation. leave the first space blank to select all of the lonitudes. The use the colon notation to select the range of values between the tropic of Cancer and the tropic of Capricorn.
tropics_yield_slice = temp_slice[ , tropic_cancer:tropic_capricorn]
# Make a quick plot of our subsetted data. It will obviously look distorted as it is being streched by the image function. There are several ways to make a correctly scaled map for a subset, but that is outside of the scope of this R notebook.
image(tropics_yield_slice)
# The polar regions are regions above 60 degrees north and below 60 degrees south lattitude. However remember our grid goes from 0 to 180 at the sides, not from -90 to +90. Therefore to get the correct locations we do 90-[lattitude of interest] and 90+[lattitude of interest]
polar_south = 90 - 60
polar_north = 90 + 60
# use the square bracket notation to subset our grid of data. Leave the first space before the comma blank to select all longitudes. The second space is a little complex. We use 1:polar_south to get the south polar region, and polar_north:180 to get the north polar region. We then use the concatenate function "c()" to stick the two blocks of data together to allow subsetting. This is a little complex I realize, but just copy and paste this code if you need it.
polar_yield_slice = temp_slice[ , c(1:polar_south, polar_north:180) ]
# Make a quick plot of the data. Note it will look weird because Antarctica and lots of Arctica Canada and Greenland don't appear to have been modelled. However you can see the top of Norway and parts of Russia.
image(polar_yield_slice)
# The polar regions are regions above 60 degrees north. However remember our grid goes from 0 to 180 at the sides, not from -90 to +90. Therefore to get the correct locations we do 90-[lattitude of interest] or 90+[lattitude of interest] depending of whether we are looking at the north or south pole.
polar_north = 90 + 60
# use the square bracket notation to subset our grid of data. Leave the first space before the comma blank to select all longitudes. The second space is a little complex. We use polar_north:180 to get the north polar region.
n_polar_yield_slice = temp_slice[ , polar_north:180 ]
# Make a quick plot of the data. Note it will look weird because Antarctica and lots of Arctica Canada and Greenland don't appear to have been modelled. However you can see the top of Norway and parts of Russia.
image(n_polar_yield_slice)
# The longitude bounds for north and south America are roughly 160 degrees west to 30 degrees west. However remember our matrix goes from 0 at the left hand side to 360 at the right hand side, rather than the more familliear -180 to +180. Therefore we need to do 180-160 for 160 degrees west and 180-30 for 30 degrees west.
lat1 = 180 - 160
lat2 = 180 - 30
# Select the longitude slide using the lat1:lat2 colon notation to select the range of values. Leave the space after the comma blank to select all values for lattitude.
polar_yield_slice = temp_slice[lat1:lat2, ]
# Make a quick plot of the lattitude slice.
image(polar_yield_slice)
# Subset both lattitude and longitude to find australia. Here I just played with values to find the correct bounds for Australia, rather than the method above.
australia_yield_slice = temp_slice[290:335 , 45:80]
# Make a quick plot of the data.
image(australia_yield_slice)
# Demonstrating the idea of how to subset data in R using a mask. We want to have a mask filled with NAs where we want to not have data, and 1s where we do have data.
pretend_data1 = c(0,1,2,3,4,5)
pretend_mask1 = c(1,1,NA,1,1,1)
# When we multiple our mask and our data, the data will stay the same where it is being multiplied by 1, but will change to NA where it is multiplied by NA. This example demonstrates masking out just one value.
pretend_data1 * pretend_mask1
# Demonstrating the idea of how to subset data in R using a mask. We want to have a mask filled with NAs where we want to not have data, and 1s where we do have data.
pretend_data2 = c(0,1,2,3,4,5)
pretend_mask2 = c(NA,NA,NA,1,NA,NA)
# When we multiple our mask and our data, the data will stay the same where it is being multiplied by 1, but will change to NA where it is multiplied by NA. This example demonstrates masking out all except one value.
pretend_data2 * pretend_mask2
# Read in a NetCDF file containing a mask for forest regions around the world. Here we use the same NetCDF workflow as shown in Notebook 2, but much reduced.
# Open a file connection to the NetCDF containing the mask values
ncfile = nc_open("ESA_forest_9regions_v2_1deg.nc")
# Print the header information for the NetCDF file
print(ncfile)
# Use the ncvar_get() function to get the values of the mask
mask = ncvar_get(ncfile, 'region_mask')
# Close the connection to the NetCDF file.
nc_close(ncfile)
# Make a quick plot of the values in the mask file
image.plot(lon, lat, mask, col=rainbow(9), legend.lab="Number of the zone in the mask")
map(database = 'world', add = T, lwd=1.5)
# After plotting the mask, we see that the format of the mask is numbers from 1 to 9, rather than the 1s and NAs that we want. Here we make a new mask for tropical broadleaved deciduous forest using the ifelse() function. This line of code makes a matrix where tropical broadleaved deciduous forest are set to 1, while the rest of the matrix is set to NA. This matrix is then saved to the variable tropical_broad_dec_mask.
tropical_broad_dec_mask = ifelse(mask == 2,1,NA)
# Select that data by multiplying the data in first_yield_slice by the mask.
first_yield_slice_tropical_broad = first_yield_slice * tropical_broad_dec_mask
# Make a plot of our subsetted data.
image.plot(lon, lat, first_yield_slice_tropical_broad, legend.lab="Yield (t ha-1 yr-1 (dry matter))")
map(database = 'world', add = T, lwd=1.5)
# Summary statistics are things like mean, median, maximum, minimum, interquartile ranges, etc. Summary statistics are often the best way to answer scientific questions, such as "what is the maximum modeled temperature in a tropic broadleaf forest". Let's see an example of how easy it is to get a summary statistic for the yield of the tropical broadleaf forests
mean(first_yield_slice_tropical_broad, na.rm = T)
# Make a new mask for tropical broadleaved deciduous forest using the ifelse() function. This line of code makes a matrix where tropical broadleaved deciduous forest are set to 1, while the rest of the matrix is set to NA. This matrix is then saved to the variable tropical_broad_dec_mask.
tropical_broad_ever_mask = ifelse(mask == 1,1,NA)
# Select that data by multiplying the data in first_yield_slice by the mask.
first_yield_slice_tropical_broad_ever = first_yield_slice * tropical_broad_ever_mask
# Make a plot of our subsetted data.
image.plot(lon, lat, first_yield_slice_tropical_broad_ever, legend.lab="Yield (t ha-1 yr-1 (dry matter))")
map(database = 'world', add = T, lwd=1.5)
# Find the maximum yield in this subset
max(first_yield_slice_tropical_broad_ever, na.rm=T)
# Here we extract a time series from the yield data by specifying a single lattitude and longitude, but then leave the third space inside the square brackets blank to select all time slices at that lat/long location.
time_series_australia = yield[250,60,]
# Plot the time series we have just extracted.
plot(time_series_australia, type='l', xlab="Time step", ylab='Yield (t ha-1 yr-1 (dry matter))')
# Finally, make a histogram of our time series data. Just because we can.
hist(time_series_australia, col='black', main='', xlab='Yield')
# Add a box around our plot - just because I think it looks nicer! Remember to run this chunk all at once with Ctrl+Shift+Enter (or Cmd+Shift+Enter on Mac).
box()
# This line of code extracts all R code from this document
knitr::purl("Rmd_script_3_masking.Rmd", output="Script_3_R_code_only.R")
# Set the working directory to the folder where the data is saved.
setwd("~/Documents/scratch/R_netcdf") # This is the file path to where I have saved my data files on my computer. Your file path will be different. Either use Windows Explorer (Finder on a mac) to find the file path, or use the menu at the top of R studio to set the working directory instead. If you want to use the menu instead of this line of code, at the top of R studio click Session >  Set working directory > Choose directory, and navigate to the folder where the data files are saved.
# Install the "ncdf4" package from the internet. This normally only needs to be done a single time on a computer, and then it is installed forever.
install.packages("ncdf4")
# Load the "ncdf4" package into R. This needs to be done at the start of every R script that uses the package.
library("ncdf4")
# Open a connection to the NetCDF file and store this connection in a variable called ncfile. (don't worry about what we mean by a "connection" to the file, this will become clear throughout the examples.)
ncfile <- nc_open('2016722131556EnsembleGPP_MR_1deg.nc')
# Print the header of the NetCDF file (i.e. print the NetCDF file's metadata)
print(ncfile)
# Extract the 'lat' variable in the netcdf file, and store it in a variable called 'lat' in R.
lat=ncvar_get(nc=ncfile, varid='lat')
# Extract the 'lon' variable in the netcdf file, and store it in a variable called 'lon' in R.
lon=ncvar_get(nc=ncfile,varid='lon')
# Extract the 'time' variable in the netcdf file, and store it in a variable called 'time' in R.
time=ncvar_get(nc=ncfile, varid="time")
# Extract the 'gpp' variable in the netcdf file, and store it in a variable called 'gpp' in R.
gpp = ncvar_get(nc=ncfile, varid='gpp')
# Use the length function to see how long each variable is
length(lat)
length(lon)
length(time)
length(gpp)
# Close the NetCDF file connection
nc_close(ncfile)
# Find the dimensions of the gpp variable
dim(gpp)
# Extract the first time slice from the gpp variable
first_gpp_slice = gpp[,,1]
# Sanity check the dimensions of our first_gpp_slice. Should be 360 by 180
dim(first_gpp_slice)
# Make a quick plot of the first time slice.
image(first_gpp_slice)
# The map was upside down, so were we extract the first time slice again, but flip it's y axis as we extract it. This is what the 180:1 is doing. 180 is the greatest number and 1 is the least, therefore we are saying take the last value and put it first and take the second to last value and put it second, etc. It flips the matrix.
flipped_first_gpp_slice = gpp[,180:1,1]
# Plot our new flipped matrix.
image(flipped_first_gpp_slice)
# install the fields package, which as the image.plot() function. Uncomment the line below (to "uncomment" just means to delete the '#' symbol at the start of the line) to run it for the first time.
# install.packages("fields")
# Load the fields package with the library() function
library("fields")
# Make a plot of our matrix using the image.plot() function, which adds a colourbar automatically. The first argument is the values to use for the x axis, the second argument is the values for the y axis, and the third argument is the actual data values.
image.plot(lon, lat, flipped_first_gpp_slice)
# Same as the previous plot code but...
image.plot(lon, lat, flipped_first_gpp_slice)
# ... add a low resolution set of coastlines over the top for context.
map(database = 'world', lwd=1.5, add = T, col='black')
# Install the RColorBrewer package, to give us access to lots of extra colour paletts. Uncomment and run the line below the first time on a computer.
# install.packages("RColorBrewer")
# Load the RColorBrewer into R with the library() function.
library("RColorBrewer")
# The same plot and map commands as before, but with the prewer.pal(10,'RdBu) function, which gives us a Red to Blue color ramp with 10 levels. This is then enclosed with the rev() function, which reverses the order of the red-blue color ramp to give us a blue-red color ramp, which is more normal for Environmental sciences.
image.plot(lon, lat, flipped_first_gpp_slice, col = rev(brewer.pal(10, "RdBu")))
map(database = 'world', add = T, lwd=1.5)
# The same image.plot() and map() code as before, but with a yellow-green-blue color palette.
image.plot(lon, lat, flipped_first_gpp_slice, col = rev(brewer.pal(9,"YlGnBu")))
map(database = 'world', add = T, lwd=1.5)
# Change the margins of the plot, to stop to padding cutting the ends off our very long title.
par(mar=c(5.1,3,4.1,3))
# Same image.plot() and map() code as last time, but remove x and y labels (with xlab= and ylab=), add a main title (with main=), add a legend lable (with legend.lab=), and adjust the location and padding of the legend label so it is not under the legend text (with legend.line= and legend.mar=)
image.plot(lon, lat, flipped_first_gpp_slice, col = rev(brewer.pal(9,"YlGnBu")), xlab="", ylab="", main="Carbon Mass Flux out of Atmosphere due to Gross Primary Production on Land", legend.lab="kg m-2 s-1", legend.line=4, legend.mar=7)
map(database = 'world', add = T, lwd=1.5)
# Install the colourblind and black and white printer firneds viridis colour palettes
# install.packages("viridis")
# load the viridis package
library("viridis")
# Same par(), image.plot() and map() functions as before, but using the viridis colour palette.
par(mar=c(3,3,3,3))
image.plot(lon, lat, flipped_first_gpp_slice, col=viridis(256), xlab="", ylab="", main="Carbon Mass Flux out of Atmosphere due to Gross Primary Production on Land", legend.lab="kg m-2 s-1", legend.line=4, legend.mar=7)
map(database = 'world', add = T, lwd=1.5)
# Open a png graphcs device to export a plot, and make a plot which is 10 inches by 5 inches, and save at a resolution of 300 dpi.
png("gpp_map.png", width=10, height=5, units = 'in', res = 300)
# Same par(), image.plot() and map() functions as before, but using the plasma color palette from the viridis package.
par(mar=c(3,3,3,3))
image.plot(lon, lat, flipped_first_gpp_slice, col=plasma(256), xlab="", ylab="", main="Carbon Mass Flux out of Atmosphere due to Gross Primary Production on Land", legend.lab="kg m-2 s-1", legend.line=4, legend.mar=7)
map(database = 'world', add = T, lwd=1.5)
# close the png graphics device to complete exporting the plot.
dev.off()
# This line of code extracts all R code from this document
knitr::purl("Rmd_script_2_netcdf.Rmd", output="Script_2_R_code_only.R")
install.packages("fields", type="binary")
# replace netCDF _FillValues with NA's
gpp[gpp==9999] = NA
# Use the head() function to see the first 5 entries of each variable, to help us understand our data.
head(gpp)
# Print the last few values in the gpp variable to see if it is still full of NAs.
tail(gpp)
# Remove all the NAs, and sum up any numbers that remain. If we get a value of 0, there is no data in the gpp variable and it is all NAs, which probably means we have loaded the file incorrectly. If we get any value above 0 then the gpp variable does have some data in it. If the function returns NA, then we have forgotten to use the na.rm=TRUE function arguemnt.
sum(gpp, na.rm=TRUE)
install.packages("fields", type = "binary")
my_var = 144 # creates a variable called "my_var" and stores the number 144 in it.
# Print the contents of my_var to the screen
my_var
# For example, we can add a number to a variable like this:
my_var + 4
# Subtraction:
my_var - 7.5
# Multiplication
my_var * 1000
# Division
my_var / 12
# Brackets and longer expressions
((my_var + 4) / 10) + (2*my_var) + (1/4)
# Raising to a power
my_var^2
# Create a new variable and store the value of Pi in it
pi_3dp = 3.142
# Create a radius variable and store the radius of some circle in it
radius = 5
# Find the area of this circle
circle_area = pi_3dp * radius^2
# Print the contents of circle_area to the screen
circle_area
# Make a variable containing a string
my_fav_sentence = "climate data is cool"
# Print the contents of the varible
my_fav_sentence
# Make a vector containing the start of the Fibonacci sequence
fib = c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
# Print the contents of the fib variable to the screen
fib
# Multiply every number inside the fib variable by 2.
fib * 2
# Create a matrix of test data
my_mat = matrix(1:12, nrow=3)
# Print the matrix to the screen
my_mat
# The "data()" function is a special function in R that loads a small practise dataset for you into a variable of the same name as between the quotes (in this case, "faithful"). This is not the normal way to load data into R, so don't worry about it!
data("faithful")
faithful
# Find the dimensions of the data stored in the faithful variable
dim(faithful)
# Print the structure of the faithful variable to the screen
str(faithful)
# print the whole eruptions column
faithful$eruptions
# Print the fifth row of the first column of the faithful dataset
faithful[5,1]
# Print the first 5 rows of the first column
faithful[1:5, 1]
# Print rows 10 to 41 of the second column
faithful[10:41,2]
# Select all of the second column in the dataset (this is equivalent to faithful$waiting)
faithful[ ,2]
# Make a scatter plot of old faithful eruptions
plot(x=faithful$eruptions, y=faithful$waiting)
# Change plot symbols
plot(x=faithful$eruptions, y=faithful$waiting, pch=17)
# Change the color of the symbols. Don't forget to put quotation marks around "red", as it is a string of characters, and R likes strings of characters to be enclosed with quotation marks. Otherwise R would think red was a variable.
plot(x=faithful$eruptions, y=faithful$waiting, pch=17, col="red")
# Use extra function arguments in the plot() function to change the axis labels.
plot(x=faithful$eruptions, y=faithful$waiting, pch=17, col="red", xlab="Eruption time (minutes)", ylab="Time between eruptions (minutes)")
# Use extra function arguemnts for the plot() function to add a title, remove excess white space, and change the limits of the plot.
plot(x=faithful$eruptions, y=faithful$waiting, pch=17, col="red", xlab="Eruption time (minutes)", ylab="Time between eruptions (minutes)", main="Old faithful eruption times", xaxs="i", yaxs="i", xlim=c(0,6), ylim=c(0, 120))
# Add a subtle grid to the plot. Note that this whole code chunk must be run at the same time with the Ctrl+Shift+Enter command, rather than running one line at a time with Ctrl+Enter (or Cmd+Enter on a mac), which will cause an error due to the plot already being printed to the screen.
plot(x=faithful$eruptions, y=faithful$waiting, pch=17, col="red", xlab="Eruption time (minutes)", ylab="Time between eruptions (minutes)", main="Old faithful eruption times", xaxs="i", yaxs="i", xlim=c(0,6), ylim=c(0, 120))
grid()
# Open R's internal documentation on the plot function() - this is useful for when you don't have an internet connection. If you do have an internet connection, the internet is often more useful for R questions than the internal documentation, which is sometimes not very clearly written.
?plot
# Set the working directory, so R can find the data files.
setwd("~/Documents/scratch/R_netcdf") # This is the file path to where I have saved my data files on my computer. YOUR FILE PATH WILL BE DIFFERENT. Either use Windows Explorer (Finder on a mac) to find the file path, or use the menu at the top of R studio to set the working directory instead. If you want to use the menu instead of this line of code, at the top of R studio click Session >  Set working directory > Choose directory, and navigate to the folder where the data files are saved.
# Read in the data
my_data = read.table("global_co2_ann.out")
# Quality check the data loading
dim(my_data)
str(my_data)
# Set the column names in the dataframe stored in the variable called my_data
names(my_data) = c("year", "co2")
# Check that the data names have changed
str(my_data)
# Plot the ASCII time series data. Note the new expression() function, which allows mathematical expressions, superscripts and subscripts to be used in plot labels.
plot(x=my_data$year, y=my_data$co2, xlab="Year", ylab=expression("Annual CO"[2] * " (ppm)"))
# Change from a scatter graph to a line graph with the type='l' function argument. lwd=2 changes the line width.
plot(x=my_data$year, y=my_data$co2, xlab="Year", ylab=expression("Annual CO"[2] * ' (ppm)'), type='l', lwd=2, col="darkgreen")
## RUN THIS CODE CHUNK ALL AT THE SAME TIME using Ctrl+Shift+Enter on a PC or Cmd+Shift+Enter on a Mac.
# Open a plot using the jpeg() function. This gives a plot 5 inches across and 4 inches high with a resolution of 300 dots per inch. This is important because many journals demand plots and figures in a certain dpi! Must run the dev.off() function after the plotting command to complete the plot saving process.
jpeg(filename="my_first_plot.jpg", width=5, height=4, units='in', res=300)
# Change from a scatter graph to a line graph with the type='l' function argument. lwd=2 changes the line width.
plot(x=my_data$year, y=my_data$co2, xlab="Year", ylab=expression("Annual CO"[2] * ' (ppm)'), type='l', lwd=2, col="darkgreen")
# Close the graphics device to save the plot with dev.off(). If the plot is saved sucessfullly, "null device 1" should be printed in R, and the plot should appear in your working directory.
dev.off()
# This line of code extracts all R code from this document
knitr::purl("Rmd_script_1_using_R.Rmd", output="Script_1_R_code_only.R")
setwd("~/Documents/scratch/r_swirlify")
test_lesson()
library("swirlify")
swirlify()
set_lesson()
swirlify()
test_lesson()
